# 谜题 33：循环者遇到了狼人

## 背景

补码算术运算、溢出。

## 代码

请提供一个对 i 的声明，将下面的循环转变为一个无限循环。这个循环不需要使用任何 5.0 版的特性（被包装数字类型）： 

```java
while (i != 0 && i == -i) {
} 
```

## 陷阱

在布尔表达式( i != 0 && i == -i )中，一元减号操作符作用于 i，这意味着它的类型必须是数字型的：一元减号操作符作用于一个非数字型操作数是非法的。

因此，我们要寻找一个非 0 的数字型数值，它等于它自己的负值。NaN 不能满足这个属性，因为它不等于任何数值，因此，i 必须表示一个实际的数字。

浮点数值是用一个符号位、一个被通俗地称为尾数（mantissa） 的有效数字以及一个指数来表示的。除了 0 之外，没有任何浮点数等于其符号位反转之后的值，因此 i 的类型必然是整数型的。 

## 解惑

有符号的整数类型使用的是 2 的补码算术运算：为了对一个数值取其负值，你要反转其每一位，然后加 1，从而得到结果。

2 的补码算术运算的一个很大的优势是，0 具有唯一的表示形式。如果你要对 int 数值 0 取负值，你将得到 0xffffffff+1，它仍然是 0。 

总共存在偶数个 int 数值——准确地说有 2^32个——其中一个用来表示 0，这样就剩些奇数个 int 数值来表示正整数和负整 数，这意味着正的和负的 int 数值的数量必然不相等。这暗示着至少有一个 int 数值，其负值不能正确地表示成为一个 int 数值，它就是 Integer.MIN_VALUE，即-2^31，十六进制表示是 0x80000000，其符号位为 1，其余所有的位都是 0。

如果我们对 Integer.MIN_VALUE取负值，那么我们将得到 0x7fffffff+1，也就是 0x80000000，即 Integer.MIN_VALUE！换句话说，Integer.MIN_VALUE 是它自己的负值， Long.MIN_VALUE 也是一样。对这两个值取负值将会产生溢出，但是 Java 在整数计算中忽略了溢出。

## 解决办法或规则

下面的声明将使得布尔表达式(i != 0 && i == -i)的计算结果为 true，从而使 循环无限环绕下去： 

```java
int i = Integer.MIN_VALUE;
//下面这个也可以：
long i = Long.MIN_VALUE; 

while (i != 0 && i == -i) {
} 
```

Java 的 int 算术运算是实际的算术运算对 2^32取模的运算，因此本谜题需要一个对这种线性全等的非 0 解决方案：  

```java
i ≡ -i(mod 232)
//将 i 加到恒等式的两边，我们可以得到：
2i ≡ 0(mod 32) 
```

对这种全等的非 0 解决方案就是 i = 2^31。尽管这个值不能表示成为一个 int， 但是它是和-2^31全等的，即与 Integer.MIN_VALUE 全等。  

总之，Java 使用 2 的补码的算术运算，它是非对称的。对于每一种有符号的整数类型（int、long、byte 和 short），负的数值总是比正的数值多一个，这个多出来的值总是这种类型所能表示的最小数值。

- 对 Integer.MIN_VALUE 取负值得到的还是它没有改变过的值，Long.MIN_VALUE 也是如此。
- 对 Short.MIN_VALUE 取负值并将所产生的 int 数值转型回 short，返回的同样是最初的值 Short.MIN_VALUE。
- 对 Byte.MIN_VALUE 来说，也会产生相似的结果。