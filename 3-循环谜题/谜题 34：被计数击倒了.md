# 谜题 34：被计数击倒了  

## 背景

精度丢失。

## 代码

下面的程序有一个单重的循环，它记录迭代的次数，并在循环终止时打印这个数。那么，这个程序会打印出什么呢？  

```java
public class Count {
    public static void main(String[] args) {
        final int START = 2000000000;
        int count = 0;
    
        for (float f = START; f < START + 50; f++)
            count++;
    
        System.out.println(count);
    }
}
```

## 陷阱

表面的分析也许会认为这个程序将打印 50，毕竟，循环变量（f）被初始化为2,000,000,000，而终止值比初始值大 50，并且这个循环具有传统的“半开”形式：它使用的是 < 操作符，这是的它包括初始值但是不包括终止值。  

循环变量是 float 类型的，而非 int 类型的。  很明显，增量操作（f++）不能正常工作。F 的初始值接近于Integer.MAX_VALUE，因此它需要用 31 位来精确表示，而 float 类型只能提供24 位的精度。对如此巨大的一个 float 数值进行增量操作将不会改变其值。

因此，这个程序看起来应该无限地循环下去，因为 f 永远也不可能解决其终止值。但是，如果你运行该程序，就会发现它并没有无限循环下去，事实上，它立即就终止了，并打印出 0。怎么回事呢？  

## 解惑

这个循环只有在循环索引 f 比(float)(START + 50)小的情况下才运行。在将一个 int与一个 float 进行比较时，会自动执行从 int 到 float 的提升。遗憾的是，这种提升是会导致精度丢失的三种**拓宽原始类型转换**的一种。（另外两个是从 long 到 float 和从 long 到 double。）  

f 的初始值太大了，以至于在对其加上 50，然后将结果转型为 float 时，所产生的数值等于直接将 f 转换成 float 的数值。换句话说，(float)2000000000 ==2000000050，因此表达式 f < START + 50 即使是在循环体第一次执行之前就是false，所以，循环体也就永远的不到机会去运行。  

## 规则或告警

修正：只需将循环变量的类型从 float 修改为 int 即可。这样避免了所有与浮点数计算有关的不精确性：  

```java
for (int f = START; f < START + 50; f++)
    count++;
```

总之，**不要使用浮点数作为循环索引，因为它会导致无法预测的行为**。请使用 int 或 long 循环索引。  