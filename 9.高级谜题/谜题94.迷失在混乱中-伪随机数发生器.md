# 谜题 94：迷失在混乱中

## 背景

伪随机数发生器。

## 代码

下面的 shuffle 方法声称它将公平的打乱它的输入数组的次序。换句话说，假设其使用的伪随机数发生器是公正的，它将会以均等的概率产生各种排列的数组。 

它真的兑现了它的诺言吗？如果没有，你将如何订正它呢？

```java
import java.util.Random;

public class Shuffle {
    private static Random rnd = new Random();
 
    public static void shuffle(Object[] a) {
        for(int i = 0; i < a.length; i++)
            swap(a, i, rnd.nextInt(a.length));
    }
 
    private static void swap(Object[] a, int i, int j) {
        Object tmp = a[i];
        a[i] = a[j];
        a[j] = tmp;
    }
}  
```

## 陷阱

看看这个 shuffle 方法，它并没有什么明显的错误。它遍历了整个数组，将随机抽取的元素互换位置。这会公平地将数组打乱，对吗？

不对。在这里，有很严重的错误， 但是它并不明显，除非你专门研究算法。

## 解惑

如果你使用一个长度为 n 的数组作为参数去调用 shuffle 方法，这个循环体会执行 n 次。在每次执行中，这个方法会选取从 0 到 n-1 这 n 个整数中的一个。所以， 该方法就有 nn 种不同的执行动作。

我们假设随机数发生器是公平的，那么每一 种执行动作出现的概率是相等的。每一种执行动作都产生数组的一种排列。但是， 这里就有一个小问题：对于一个长度为 n 的数组来说，只有 n!种不同的排列。 （在 n 之后的感叹号表示了阶乘（factorial）操作：n 的阶乘定义为 n×(n-1) ×(n-2) ×…×1。）

问题在于，对于任何大于 2 的 n，nn 都无法被 n！整除， 因为 n!包含了从 2 到 n 的所有质数因子，而 nn 只包含了 n 所包含的质数因子。 这就毫无疑问的证明了 shuffle 方法将会更多地产生某些排列。 


## 解决办法或规则

**修正**：好了，我们的 shuffle 方法是坏掉了。我们怎么修复它呢？使用类库中提供的 shuffle 方法： 

```java
import java.util.*;

public static void shuffle(Object[] a) {
    Collections.shuffle(Arrays.asList(a));
} 
```

如果库中有可以满足你需要的方法，请务必使用它。一般来说，库提供了高效的解决方案，并且可以让你付出最小的努力。 

**修正**：另外，在你忍受了所有这些数学的东西之后，如果不告诉你如何修复这个坏掉的 shuffle 方法是不公平的。

修复方法是非常直接的。在循环体中，将当前的元素和某个在当前元素与数组末尾元素之间的所有元素中随机选择出来的元素进行互换。不要去碰那些你已经进行过值互换的元素。这本质上也就是库中的方法所使用的算法： 

```java
public static void shuffle(Object[] a) {
    for(int i = 0; i < a.length; i++)
        swap(a, i, i + rnd.nextInt(a.length - i));
} 
```

使用归纳法很容易证明这个方法是公平的。最基础情况，让我们观察长度为 0 的数组，这显然是公平的。根据归纳法的步骤，如果你将这个方法用在一个长度 n>0 的数组上，它会为这个数组的 0 位置上的元素随机选择一个值。然后，它会遍历数组剩下的元素：在每个位置上，它会在“子数组”中随机选择一个元素， 这个子数组从当前位置开始到原数组的末尾。对于从位置 1 到原数组末尾的这个长度为 n-1 的子数组来说，如果将该方法作用在这个子数组上，它实际上也是在做上述的事。这就完成了证明。它同时也提供了 shuffle 方法的递归形式，它的细节就留给读者作为练习了。 

你可能会认为到此为止就是故事的全部内容了，但却还有一部分内容。你设想过这个经过修复的 shuffle 方法会等概率的产生一个表示 52 张牌的 52 个元素的数组的所有排列吗？毕竟我们只是证明了它是公平的。在这里你可能不会很惊讶地 发现答案很显然是“不”。这里的问题是，在谜题的开始，我们做出了“使用的伪随机数发生器是公平的”这一假设。但是它不是。 

这个随机数发生器，java.util.Random，使用的是一个 64 位的种子，而它产生的随机数完全是由这个种子决定的。52 张牌有 52!种排列，而种子却只有 264 个。它能够覆盖的排列占所有排列的多少呢？你相信是百分之 2.3×10-47 吗？ 这只是委婉地表示了“实际上就没怎么覆盖”。

如果你使用 java.security.SecureRandom 代替 java.util.Random，你会得到一个 160 位的 种子，但是它给你带来的东西少得惊人：对于元素个数大于 40 的数组，这个 shuffle 方法仍然不能返回它的某些排列(因为 40!>2160) 。对于一个 52 个元素的数组，你只能获得所有可能的排列的百分之 1.8×10-18 。 

这难道意味着你在洗牌的时候不能相信这些伪随机数发生器吗？这要看情况。它们确实只能产生所有可能排列的微不足道的一部分，但是它们没有我们前面所看到的那种系统性的偏差。公平地讲，这些发生器在非正式的场景中已经足够好用了。如果你需要一个尖端的随机数发生器，那你就需要到别的什么地方去寻找了。 

总之，像很多算法一样，打乱一个数组是需要慎重对待的。这么做很容易犯错并且很难发现错误。在其他条件相似的情况下，你应该优先使用类库而不是手写的代码。如果你想学习更多的关于本谜题的论题的内容，请参见[Knuth98 3.4.2]。 