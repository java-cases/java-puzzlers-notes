# Java位运算符及二进制常识

## 一、位运算

| 位运算符 | 解释                            | 示例          | 十进制 |                                  二进制 |
| :------: | :------------------------------ | ------------- | :----: | --------------------------------------: |
|    &     | 与，相同位都是1时为1，否则为0   | int a= 1 & 2  |   1    | 0000 0000 0000 0000 0000 0000 0000 0001 |
|          |                                 |               |   2    | 0000 0000 0000 0000 0000 0000 0000 0010 |
|          |                                 |               |   0    | 0000 0000 0000 0000 0000 0000 0000 0000 |
|    \|    | 或，相同位任一是1时为1，否则为0 | int a= 1 \| 2 |   1    | 0000 0000 0000 0000 0000 0000 0000 0001 |
|          |                                 |               |   2    | 0000 0000 0000 0000 0000 0000 0000 0010 |
|          |                                 |               |   3    | 0000 0000 0000 0000 0000 0000 0000 0011 |
|    ~     | 非，原位是1时为0，原位是0时为1  | int a= ~0     |   0    | 0000 0000 0000 0000 0000 0000 0000 0000 |
|          |                                 |               |   -1   | 1111 1111 1111 1111 1111 1111 1111 1111 |

　　![img](https://static.oschina.net/uploads/img/201612/29081609_ElGt.jpg)

 

## **二、位移运算**

　　![img](https://static.oschina.net/uploads/img/201612/29081609_wD94.jpg)



## **三、二进制数**

　　以Java中最常使用的int类型为例(32位)。

　　![img](https://static.oschina.net/uploads/img/201612/29081609_Kzli.jpg)



## ㈠ 符号位

　　二进制数最左端的数字为符号位：**0代表正，1代表负**。

 

## ㈡ 最大与最小

　　⑴  1是最小的正整数，符号位为0，最后一位为1，其它全部为0。

　　递增：二进制数右端每次加1(逢2进1),一直到31个非符号位的0全部变为1，得到最大的正整数2147483647。

　　⑵ -1是最大的负整数，符号位为1，其它31位也全部为1。

　　递减：二进制数右端每次减1(逢0借1)，一直到31个非符号位的1全部变成0，得到最小的负整数为-2147483648。



## ㈢ 原码、补码、反码

### 　　**⑴ 原码**

　　根据数学上的表示习惯：“+”代表为正数，只要将“+”变为“-”，那么就是对应的负数。譬如 +1 对应的负数为 -1。

　　根据这个原则，二进制数的负数表示本来应该如下图：

　　![img](https://static.oschina.net/uploads/img/201612/29081609_E8vr.jpg)

　　以正数的二进制数表示为基准，负数的表示只改变符号位，这样的表示方式就是**原码**。因此，**正数的表示方式都是原码。**

　　事实上的二进制的负数并不是如上面的原码这样表示，譬如-1是32个1。那么这样的表示方式是如何得到的呢？



### 　　**⑵ 反码**

　　反码就是将原码除符号位以外的值全部取反，原来是1的变为0，原来是0的变为1。例如使用-1的原码得到的反码如下图所示：

　　![img](https://static.oschina.net/uploads/img/201612/29081609_5uLh.jpg)



### 　　**⑶ 补码**

　　补码就是在反码的基础上，在二进制数的右端末位加1(逢2进1)。如下图所示：

　　![img](https://static.oschina.net/uploads/img/201612/29081609_afoE.jpg)

　　对比本节开始的图，你会发现补码的32个1正是十进制表示的 -1。

　　原码、反码和补码都是计算机的定点表示法。事实上，当前的绝大多数计算机使用的都是补码表示法，虽然历史上曾经生产过反码表示的计算机。

　　C语言标准没有明确规定必须使用补码表示法，Java则明确规定了必须使用补码表示法。



### 　　**⑷ 总结**

　　正数的原码和反码和补码都一致；负数的原码是正数的符号位取反；负数的反码是原码的非符号位取反；负数的补码是反码加1。

　　但，使用补码表示有何好处呢？



## **㈣ 补码的好处**

　　以 +1 和 -1 作加法运算为例，如下图所示：

　　![img](https://static.oschina.net/uploads/img/201612/29081609_qSqy.jpg)

　　相信你已经发现，1 + (-1) 这样的加法运算只要将二进制数相加，然后-1的末位就会变成2，根据逢2进1机制，从右至左依次所有位都会变成0。

　　最后，最左端的符号位也会进位1变成0，丢弃溢出的1，就得到最后的结果0的二进制表示32个0。

　　对照本节开头的图，会发现所有的减法都可以转换成二进制位的加法运算：1-2 可以转换成1+(-2)，(-1)-(-2)可以转换成-1+2……

　　这跟数学中的表示是一样的，而且非常地方便计算（很多计算机科学家都是从数学领域转入计算机工程，所以在很多细微之处的都能见到数学的影子）。因此，现代计算机硬件结构实际上只设计了加法器，大部分的减法其实都是转换成加法后再运算。

 

## **四 小技巧**

1.  **乘法除法**：n * 2 等价于 n << 1； n * 5 等价于 n << 2 + 1； n / 2 等价于 n >> 1。

   备注：JVM执行时会自动转化，大部分其它高级语言的编译器会做类似优化转换，所以除非有特殊的理由，否则别这么写。

2.  **取低位**：n & 0x0000FFFF；取高位：n & 0xFFFF0000。

3. **奇偶判断**：n & 1，等于0为偶，否则~~等于1~~为奇。

4. **正负判断**：(n >>> 31) & 1，等于0为正，等于1为负。

5. **取余**：n % m ，如m为2的幂次方，可用(n & (m - 1))替代。

　

　　本文简单了介绍二进制的基本常识，希望能帮助大家在阅读源码、学习汇编和操作系统等底层原理时能更好地理解内容，与及帮助下那些在学习原码、反码、补码时被很多博客或者资料绕得云里雾里的人们。

　　最后，如有错误之处请务必指正，谢谢！

 

**参考资料：**

 《深入理解计算机系统》Randal E.Bryant  David R.O’Hallaron



转载于：https://my.oschina.net/xcafe/blog/814127