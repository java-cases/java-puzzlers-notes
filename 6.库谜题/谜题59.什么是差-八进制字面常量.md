# 谜题 59：什么是差  

## 背景

八进制字面常量。

## 代码

下面的程序在计算一个 int 数组中的元素两两之间的差，将这些差置于一个集合中，然后打印该集合的尺寸大小。

那么，这个程序将打印出什么呢？  

```java
import java.util.*;

public class Differences {
    public static void main(String[ ] args) {
        int vals[ ] = { 789, 678, 567, 456, 345, 234, 123, 012 };

        Set diffs = new HashSet();
        for (int i = 0; i < vals.length; i++)
            for (int j = i; j < vals.length; j++)
                diffs.add(vals[i] - vals[j]);

        System.out.println(diffs.size());
    }
}
```

## 陷阱

外层循环迭代数组中的每一个元素，而内层循环从外层循环当前迭代到的元素开始迭代到数组中的最后一个元素。因此，这个嵌套的循环将遍历数组中每一种可能的两两组合。（元素可以与其自身组成一对。）

这个嵌套循环中的每一次迭代都计算了一对元素之间的差（总是正的），并将这个差存储到了集合中，集合是可以消除重复元素的。因此，本谜题就带来了一个问题，在由 vals 数组中的元素结成的对中，有多少唯一的正的差存在呢？    

当你仔细观察程序中的数组时，会发现其构成模式非常明显：连续两个元素之间的差总是 111。因此，两个元素之间的差是它们在数组之间的偏移量之差的函数。  

看起来不同的差的数量与元素间不同的距离的数量是相等的，也就是等于数组的尺寸，即 8。如果你运行该程序，就会发现它打印的是 14。怎么回事呢？  

## 解惑

数组中的最后一个元素是 10 而不是 12 ，因为以 0 开头的整数类型字面常量将被解释成为八进制数值。这个隐晦的结构是从 C 编程语言那里遗留下来东西，C 语言产生于 1970 年代，那时八进制比现在要通用得多。  

## 解决办法或规则

本谜题的教训很简单：**千万不要在一个整型字面常量的前面加上一个 0，这会使它变成一个八进制字面常量**。有意识地使用八进制整型字面常量的情况相当少见，你应该对所有的这种特殊用法增加注释。