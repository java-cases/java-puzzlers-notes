# 谜题 57：名字里有什么

## 背景

hashCode方法、equals方法。

## 代码

下面的程序包含了一个简单的不可变类，它表示一个名字，其 main 方法将一个名字置于一个集合中，并检查该集合是否确实包含了该名字。那么，这个程序到底会打印出什么呢？ 

```java
import java.util.*;

public class Name {
    private String first, last;
 
    public Name(String first, String last) {
        this.first = first;
        this.last = last;
    } 
    
    public boolean equals(Object o) {
        if (!(o instanceof Name))
            return false;
 
        Name n = (Name)o;
        return n.first.equals(first) && n.last.equals(last);
    }
 
    public static void main(String[] args) {
        Set s = new HashSet();
        s.add(new Name("Mickey", "Mouse"));
 
        System.out.println(s.contains(new Name("Mickey", "Mouse")));
    }
} 
```

## 陷阱

一个 Name 实例由一个姓和一个名构成。两个 Name 实例在通过 equals 方法进行 计算时，如果它们的姓相等且名也相等，则这两个 Name 实例相等。

该程序将第一个实例放置到了一个散列集合中，然后检查该集合是否包含第二个实例。 这两个 Name 实例是相等的，因此看起来该程序似乎应该打印 true。

如果你运行它，几乎可以肯定它将打印 false。那么这个程序出了什么问题呢？ 

## 解惑

这里的 bug 在于 Name 违反了 hashCode 约定。因为 Name 连 hashCode 都没有，但是这确实是问题所在。Name 类覆写了 equals 方法，而 **hashCode 约定要求相等的对象要具有相同的散列码**。

因为 Name 类没有覆写 hashCode 方法，所以它从 Object 那里继承了其 hashCode 实现。这个实现返回的是基于标识的散列码。换句话说，不同的对象几乎总是产生不相等的散列值，即使它们是相等的也是如此。所以说 Name 没有遵守 hashCode 的约定，因此包含 Name 元素的散列集合的行为是不确定的。 

放置散列集合过程：

1. 当程序将第一个 Name 实例放置到散列集合中时，该集合就会在某个散列位置上放置这个实例对应的项。该集合是基于实例的散列值来选择散列位置的，这个散列值是通过实例的 hashCode 方法计算出来的。 
2. 当该程序在检查第二个 Name 实例是否包含在散列集合中时，它基于第二个实例 的散列值来选择要搜索的散列位置。因为第二个实例有别于第一个实例，因此它极有可能产生不同的散列值。如果这两个散列值映射到了不同的位置，那么 contains 方法将返回 false。
3. 假设两个 Name 实例映射到了相同的位置，那又会怎样呢？我们所了解的所有的 HashSet 实现都进行了一种优化，即每一项在存储元素本身之外，还存储了元素的散列值。在搜索某个元素时，这种实现通过遍历集合中的项，去拿存储在每一项中的散列值与我们想要查找的元素的散列值进行比较，从而选取适当的散列位置。只有在两个元素的散列值相等的情况下，这种实现才会认为这两个元素相等。 这种优化是有实际意义的，因为比较散列码相对于比较元素来说，其代价要小得多。 

对散列集合来说，这项优化并不足以使其能够搜索到正确的位置；两个 Name 实例必须具有相同的散列值才能让散列集合能够将它们识别为是相等的。该程序偶尔也会打印出 true，这是因为被连续创建的两个对象偶尔也会具有相同的标识散列码。一个粗略的实验表明，这种偶然性出现的概率大约是 25,000,000 分之 一。这个实验的结果可能会因所使用的 Java 实现的不同而有所变化，但是在任何我们所知的 JRE 上，你基本上是不可能看到该程序打印出 true 的。

**规则：无论何时，只要覆写了 equals 方法，就必须同时覆写 hashCode 方法。** 

## 解决办法或规则

**修正**：要想订正该程序，只需在 Name 类中添加一个恰当的 hashCode 方法即可。

尽管任何其返回值仅有姓和名来确定的方法都可以满足 hashCode 的约定，但是高质量的散列函数应该尝试着对不同的名字返回不同的散列值。下

```java
public int hashCode() {
    return 37 * first.hashCode() + last.hashCode();
} 
```

总之，**当你覆写 equals 方法时，一定要记着覆写 hashCode 方法**。

更一般地讲， 当你在覆写一个方法时，如果它具有一个通用的约定，那么你一定要遵守它。对于大多数在Object中声明的非final的方法，都需要注意这一点。 不采用这项建议就会导致任意的、不确定的行为。  

