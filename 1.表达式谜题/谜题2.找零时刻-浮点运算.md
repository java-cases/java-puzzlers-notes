# 谜题 2：找零时刻  

## 背景

浮点运算。

## 代码

Tom 在一家汽车配件商店购买了一个价值$1.10 的火花塞，但是他钱包中都是两美元一张的钞票。如果他用一张两美元的钞票支付这个火花塞，那么应该找给他多少零钱呢？  

下面的程序，它会打印出什么呢？  

```java
public class Change{
    public static void main(String args[]){
        System.out.println(2.00 - 1.10);
    }
}
```

## 陷阱

你可能会很天真地期望该程序能够打印出 0.90，但是它如何才能知道你想要打印小数点后两位小数呢？  

如果你运行该程序，你就会发现它打印的是 0.8999999999999999。  

## 解惑

问题在于 1.1 这个数字不能被精确表示成为一个 double，因此它被表示成为最接近它的 double 值。 

浮点运算在一个范围很广的值域上提供了很好的近似，但是它通常不能产生精确的结果。例如：计算的结果为0.8999999999999999，并不是 0.9 。

二进制浮点对于货币计算是非常不适合的，因为它不可能将 0.1或者 10 的其它任何次负幂精确表示为一个长度有限的二进制小数。

## 解决办法或规则

**修正**：使用某种整数类型，例如 int 或 long，并且以分为单位来执行计算。 请确保该整数类型大到足够表示在程序中你将要用到的所有值。  

```java
System.out.println((200 - 110) + "cents"); //打印出正确答案 90分
```

**修正**：另一种方式是使用执行精确小数运算的 BigDecimal。  

```java
import java.math.BigDecimal;

public class Change1{
public static void main(String args[]){
    System.out.println(new BigDecimal("2.00").subtract(new BigDecimal("1.10")));
}
}
```

要注意一点： 一定要用BigDecimal(String)构造器，而千万不要用 BigDecimal(double)。后一个构造器将用它的参数的“精确”值来创建一个实例：new BigDecimal(.1)将返回一个表示 0.100000000000000055511151231257827021181583404541015625 的BigDecimal。  

使用 BigDecimal 的计算很有可能比那些使用原始类型的计算要慢一些，对某些大量使用小数计算的程序来说，这可能会成为问题，而对大多数程序来说，这显得一点也不重要。  

**总之， 在需要精确答案的地方，要避免使用 float 和 double；对于货币计算，要使用 int、long 或 BigDecimal。**

对于语言设计者来说，应该考虑对小数运算提供语言支持。