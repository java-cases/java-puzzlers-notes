# 谜题 8：Dos Equis  

## 背景

条件操作符，这个操作符有一个更广为人知的名 字：问号冒号操作符。

## 代码

```java
public class DosEquis{
    public static void main(String[] args){
        char x = 'X';
        int i = 0;

        System.out.println(true ? x : 0);
        System.out.println(false ? i : x);
    }
}  
```

## 陷阱

第一个 print 语句计算条件表 达式(true ? x : 0)并打印出结果，这个结果是 char 类型变量 x 的值’X’。

第二个 print 语句计算表达式(false ? i : x)并打印出结果，这个结果还是依 旧是’X’的 x，因此这个程序应该打印 XX。

然而，如果你运行该程序，你就会 发现它打印出来的是 X88。这种行为看起来挺怪的。第一个 print 语句打印的是 X，而第二个打印的却是 88。它们的不同行为说明了什么呢？ 

## 解惑

**定条件表达式结果类型的规则**：

1. **如果第二个和第三个操作数具有相同的类型，那么它就是条件表达式的类型**。换句话说，你可以通过绕过混合类型的计算来避免大麻烦。 
2. **如果一个操作数的类型是 T，T 表示 byte、short 或 char，而另一个操作数是一个 int 类型的常量表达式，它的值是可以用类型 T 表示的，那么条件表达式的类型就是 T**。 
3. **否则，将对操作数类型运用二进制数字提升，而条件表达式的类型就是第二个和第三个操作数被提升之后的类型**。 

```java
char x = 'X';
int i = 0;

//第二个操作数的类型是char，第三个操作数是一个 int 类型的常量表达式
//条件表达式的类型就是char
System.out.println(true ? 'X' : 0); 

//第二个操作数的类型是int变量，第三个操作数的类型是char
//条件表达式的类型就是第二个和第三个操作数被提升之后的类型int
System.out.println(false ? i : 'X');
```

在程序的两个条件表达式中，一个操作数的类型是 char，另一个的类型是 int。在两个表达式中，int 操作数都是 0，它可以被表示成一个 char。只有第一个表达式中的 int 操作数是常量（0），而第二个表达式中的 int 操作数是变量（i）。

第一个表达式：一个操作数的类型是 char （值为'X'），另一个操作数的类型是 int 常量 0。因此，第 2 点被应用到了第一个表达式 上，它返回的类型是 char。

第二个表达式：一个操作数的类型是 int 变量（值为0），另一个操作数的类型是char常量（值为'X'）。因此，第 3 点被应用到了第二个表达式上，其返回的类型是对 int 和 char 运用了二进制数字提升之后的类型，即 int。

条件表达式的类型将确定哪一个重载的 print 方法将被调用。对第一个表达式来说，PrintStream.print(char)将被调用，重载方法将变量 x 的值作为 Unicode 字符（X）来打印；而对第二个表达式来说， PrintStream.print(int)将被调用，重载方法将其作为一个十进制整数（88）来打印。 

至此，谜题被解开了。 

## 解决办法或规则

混合类型的计算会引起混乱，而这一点比在条件表达式中比在其它任何地方都表现得更明显。

总之，通常**最好是在条件表达式中使用类型相同的第二和第三操作数**。否则，你和你的程序的读者必须要彻底理解这些表达式行为的复杂规范。 

