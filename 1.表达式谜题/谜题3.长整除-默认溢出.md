# 谜题 3：长整除  

## 背景

拓宽原始类型转换、默认溢出。

## 代码

被除数表示的是一天里的微秒数；而除数表示的是一天里的毫秒数。这个程序会打印出什么呢？  

```java
public class LongDivision{
    public static void main(String args[]){
        final long MICROS_PER_DAY = 24 * 60 * 60 * 1000 * 1000;
        final long MILLIS_PER_DAY = 24 * 60 * 60 * 1000;
        
        System.out.println(MICROS_PER_DAY/MILLIS_PER_DAY);
    }
}
```

## 陷阱

每天的毫秒数和每天的微秒数都是常量。每天的微秒数是（24 小时/天*60 分钟/小时*60 秒/分钟*1000 毫秒/秒*1000 微秒/毫秒）。而每天的毫秒数的不同之处只是少了最后一个因子 1000。

当你用每天的毫秒数来整除每天的微秒数时，除数中所有的因子都被约掉了，只剩下 1000，这正是每毫秒包含的微秒数。除数和被除数都是 long 类型的，long 类型大到了可以很容易地保存这两个乘积而不产生溢出。因此，看起来程序打印的必定是 1000。

遗憾的是，它打印的是 5。这里到底发生了什么呢？  

## 解惑

问题在于常数 MICROS_PER_DAY 的计算“确实”溢出了。

```java
final long MICROS_PER_DAY = 24 * 60 * 60 * 1000 * 1000;
```

尽管计算的结果适合放入 long 中，并且其空间还有富余，但是这个结果并不适合放入 int 中。

- 这个计算完全是以 int 运算来执行的，并且只有在运算完成之后，其结果才被提升到long，而此时已经太迟了：计算已经溢出了，它返回的是一个小了 200 倍的数值。
- 从 int 提升到 long 是一种**拓宽原始类型转换（widening primitive conversion）**，它保留了（不正确的）数值。这个值之后被MILLIS_PER_DAY 整除，而MILLIS_PER_DAY 的计算是正确的，因为它适合 int 运算。这样整除的结果就得到了 5。

那么为什么计算会是以 int 运算来执行的呢？因为所有乘在一起的因子都是 int数值。**当你将两个 int 数值相乘时，你将得到另一个 int 数值**。Java 不具有目标确定类型的特性。  

## 解决办法或规则

**修正**：通过使用 long 常量来替代 int 常量作为每一个乘积的第一个因子，我们就可以很容易地订正这个程序。 这样做可以强制表达式中所有的后续计算都用 long 运作来完成。    

```java
final long MICROS_PER_DAY = 24L * 60 * 60 * 1000 * 1000;
final long MILLIS_PER_DAY = 24L * 60 * 60 * 1000;

System.out.println(MICROS_PER_DAY/MILLIS_PER_DAY);
```

**教训**：**当你在操作很大的数字时，千万要提防溢出**，它可是一个缄默杀手。**即使用来保存结果的变量已显得足够大，也并不意味着要产生结果的计算具有正确的类型**。当你拿不准时，就使用 long 运算来执行整个计算。 

语言设计者教训是：降低缄默溢出产生的可能性，可以通过对不会产生缄默溢出的运算提供支持来实现。程序可以抛出一个异常而不是直接溢出，就像 Ada 所作的那样，或者它们可以在需要的时候自动地切换到一个更大的内部表示上以防止溢出，就像 Lisp 所作的那样。这两种方式都可能会遭受与其相关的性能方面的损失。