# 谜题 13：畜牧场  

## 背景

字符串连接符优先级、操作符重载。

## 代码

下面的程序将打印出什么呢？  

```java
public class AnimalFarm{
    public static void main(String[] args){
        final String pig = "length: 10";
        final String dog = "length: " + pig.length();

        System.out. println("Animals are equal: "+ pig == dog);
    }
}
```

## 陷阱

对该程序的表面分析可能会认为它应该打印出 Animal are equal: true。毕竟，pig 和 dog 都是 final 的 string 类型变量，它们都被初始化为字符序列“length: 10”。

换句话说，被 pig 和 dog 引用的字符串是且永远是彼此相等的。然而，**== 操作符测试的是这两个对象引用是否正好引用到了相同的对象上**。在本例中，它们并非引用到了相同的对象上。  

你可能知道 String 类型的编译期常量是内存限定的。换句话说，**任何两个 String类型的常量表达式，如果标明的是相同的字符序列，那么它们就用相同的对象引用来表示**。如果用常量表达式来初始化 pig 和 dog，那么它们确实会指向相同的对象，但是 dog 并不是用常量表达式初始化的。  

那么，这个程序就应该打印 Animal are equal: false，对吗？  

如果你运行该程序，你就会发现它打印的只是 false，没有打印 Animal are equal: 。它怎么会不打印这个字符串字面常量呢？  

## 解惑

**规则**：**+ 操作符，不论是用作加法还是字符串连接操作，它都比 == 操作符的优先级高**。

因此，println 方法的参数是按照下面的方式计算的：

```java
System.out.println(("Animals are equal: " + pig) == dog); 
```

这个布尔表达式的值当然是 false，它正是该程序的所打印的输出。    

## 解决办法或规则

**教训**：如果可以的话，**不应该依赖于字符串常量的内存限定机制**。内存限定机制只是设计用来减少虚拟机内存占有量的，它并不是作为程序员可以使用的一种工具而设计的。就像这个谜题所展示的，**哪一个表达式会产生字符串常量并非总是显而易见**。  

**修正**：**在比较对象引用时，你应该优先使用 equals 方法而不是 == 操作符**，除非你需要比较的是对象的标识而不是对象的值。  

```java
System.out.println("Animals are equal: " + pig.equals(dog)); 
```

对语言设计者来说有两个教训：

- 字符串连接的优先级不应该和加法一样，这意味着重载 + 操作符来执行字符串连接是有问题的。
- 对于不可修改的类型，例如 String，其引用的等价性比值的等价性更加让人感到迷惑。也许 == 操作符在被应用于不可修改的类型时应该执行值比较。要实现这一点，一种方法是将 == 操作符作为 equals方法的简便写法，并提供一个单独的类似于System.identityHashCode的方法来执行引用标识的比较。  

