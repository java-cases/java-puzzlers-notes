# 谜题 18：字符串奶酪 

## 背景

字符集。

## 代码

下面的程序从一个字节序列创建了一个字符串，然后迭代遍历字符串中的字符，并将它们作为数字打印。

请描述一下程序打印出来的数字序列：  

```java
public class StringCheese {
    public static void main(String[] args) {
        byte bytes[] = new byte[256];
        for (int i = 0; i < 256; i++)
            bytes[i] = (byte)i;

        String str = new String(bytes);
        for (int i = 0, n = str.length(); i < n; i++)
            System.out.println((int)str.charAt(i) + " ");
    }
}
```

## 陷阱

首先，byte 数组用从 0 到 255 每一个可能的 byte 数值进行了初始化，然后这些byte 数值通过 String 构造器被转换成了 char 数值。

最后，char 数值被转型为int 数值并被打印。打印出来的数值肯定是非负整数，因为 char 数值是无符号的，因此，你可能期望该程序将按顺序打印出 0 到 255 的整数。

如果你运行该程序，可能会看到这样的序列。但是再运行一次，可能看到的就不是这个序列了。

我们在四台机器上运行它，会看到四个不同的序列，包括前面描述的那个序列。这个程序甚至都不能保证会正常终止，比打印其他任何特定字符串都要缺乏这种保证。它的行为完全是不确定的。  

## 解惑

这里的罪魁祸首就是 String(byte[])构造器。

有关它的规范描述道：“在通过解码**使用平台缺省字符集**的指定 byte 数组来构造一个新的 String 时，该新String 的长度是字符集的一个函数，因此，它可能不等于 byte 数组的长度。当给定的所有字节在缺省字符集中并非全部有效时，这个构造器的行为是不确定的”。  

字符集是一个包，包含了字符、表示字符的数字编码以及在字符编码序列和字节序列之间来回转换的方式。转换模式在字符集之间存在着很大的区别：某些是在字符和字节之间做一对一的映射，但是大多数都不是这样。**ISO-8859-1 是唯一能够让该程序按顺序打印从 0 到 255 的整数的缺省字符集，它更为大家所熟知的名字是 Latin-1**[ISO-8859-1]。  

J2SE 运行期环境（JRE）的缺省字符集依赖于底层的操作系统和语言。如果你想知道你的 JRE 的缺省字符集，并且你使用的是 5.0 或更新的版本，那么你可以通过调用 java.nio.charset.Charset.defaultCharset()来了解。如果你使用的是较早的版本，那么你可以通过阅读系统属性“file.encoding”来了解。  

## 解决办法或规则

**规则**：**当你在char 序列和 byte 序列之间做转换时，应该显式地指定字符集**。

除了接受 byte 数字之外，还可以接受一个字符集名称的 String 构造器 ：

```java
String str = new String(bytes, "ISO-8859-1");
```

**教训**：每当你要将一个 byte 序列转换成一个 String 时，你都在使用某一个字符集，不管你是否显式地指定了它。**如果你想让你的程序的行为是可预知的，那么就请你在每次使用字符集时都明确地指定**。

对 API 的设计者来说，提供这么一个依赖于缺省字符集的 String(byte[])构造器可能并非是一个好主意。  