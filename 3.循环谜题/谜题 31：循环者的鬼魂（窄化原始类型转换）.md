# 谜题 31：循环者的鬼魂 

## 背景

复合赋值操作符、窄化原始类型转换。

## 代码

请提供一个对 i 的声明，将下面的循环转变为一个无限循环：

```java
while (i != 0) {
    i >>>= 1;
}  
```

## 陷阱

\>\>\>=是右移操作符的赋值操作符，0 被从左移入到由移位操作而空出来的位上，即使被移位的负数也是如此。 

为了使移位合法，i 必须是一个整数类型 （byte、char、short、int 或 long）。无符号右移操作符把 0 从左边移入，因此看起来这个循环执行迭代的次数与最大的整数类型所占据的位数相同，即 64 次。例如：

```java
long i = -1; // -1L has all 64 bits set 
```

## 解惑

解决本谜题的关键在于>>>=是一个复合赋值操作符。**复合赋值操作符**包括*=、/=、%=、+=、-=、<<=、>>=、>>>=、 &=、^= 和 |=。

有关混合操作符的一个不幸的事实是，它们**可能会自动地执行窄化原始类型转换**，这种转换把一种数字类型转换成了另一种更缺乏表示能力的类型。**窄化原始类型转换可能会丢失级数的信息，或者是数值的精度**。 

## 解决办法或规则

假设你在循环的前面放置了下面的声明，从而将这个循环变成了一个无限循环：

```java
short i = -1;

while (i != 0) {
    i >>>= 1;
} 
```

因为 i 的初始值（(short)0xffff）是非 0 的，所以循环体会被执行。

在执行移位操作时，第一步是将 i 提升为 int 类型。所有算数操作都会对 short、byte 和 char 类型的操作数执行这样的提升。这种提升是一个拓宽原始类型转换，因此没有任何信息会丢失。这种提升执行的是符号扩展，因此所产生的 int 数值是 0xffffffff。

然后，这个数值右移 1 位，但不使用符号扩展，因此产生了 int 数值 0x7fffffff。最后，这个数值被存回到 i 中。为了将 int 数值存入 short 变量，Java 执行的是可怕的窄化原始类型转换，它直接将高 16 位截掉。这样就 只剩下(short)oxffff 了，我们又回到了开始处。循环的第二次以及后续的迭代 行为都是一样的，因此循环将永远不会终止。 

下面的程序过去总是保证可以打印 false，因此它必须继续保持此特征： 

```java
public class ReferenceComparison { 
    public static void main(String[] args) { 
        System.out.println( new Integer(0) == new Integer(0)); //false
    } 
} 
```

**判等操作符在其两个操作数中只有一个是被包装的数字类型，而另一个是原始类型时，执行的确实是数值比较**。因为这在 5.0 版之前是非法的，所有在这里没有任何兼容性的问题。让我们更具体一些，下面的程序在 1.4 版中是非法的，而在 5.0 版中将打印 true： 

```java
public class ValueComparison { 
    public static void main(String[] args) { 
        System.out.println( new Integer(0) == 0); //在1.4版中是非法的，而在5.0版中将打印 true
    } 
}
```

总之，**当两个操作数都是被包装的数字类型时**，数值比较操作符和判等操作符的行为存在着根本的差异：**数值比较操作符执行的是值比较，而判等操作符执行的是引用标识的比较**。 