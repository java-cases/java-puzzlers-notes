# 谜题 5：十六进制的趣事  

## 背景

混合类型计算、符号扩展。

## 代码

下面的程序是对两个十六进制（hex）字面常量进行相加，然后打印出十六进制的结果。这个程序会打印出什么呢？  

```java
public class JoyOfHex{
    public static void main(String[] args){
        System.out.println(Long.toHexString(0x100000000L + 0xcafebabe));
    }
} 
```

## 陷阱

看起来很明显，该程序应该打印出 1cafebabe。毕竟，这确实就是十六进制数字0x100000000L 与 0xcafebabe 的和。该程序使用的是 long 型运算，它可以支持 16 位十六进制数，因此运算溢出是不可能的。

然而，如果你运行该程序，你就会发现它打印出来的是 cafebabe，并没有任何前导的 1。这个输出表示的是正确结果的低 32 位，但是不知何故，第 33 位丢失了。

## 解惑

**整型字面常量：**

- 十进制字面常量具有一个很好的属性，即所有的十进制字面常量都是正的。要想书写一个负的十进制常量，可以使用一元取反操作符（-）连接一个十进制字面常量。
- 十六进制和八进制字面常量具有正的和负的数值。如果十六进制和八进制字面常量的最高位被置位了，那么它们就是负数。

在这个程序中，数字 0xcafebabe是一个 int 常量，它的最高位被置位了，所以它是一个负数。它等于十进制数值-889275714。  

该程序执行的这个加法是一种**混合类型的计算（mixed-type computation）**: 左操作数是 long 类型的，而右操作数是 int 类型的。为了执行该计算，Java 将int 类型的数值用**拓宽原始类型转换**提升为一个 long 类型，然后对两个 long 类型数值相加。因为 int 是一个有符号的整数类型，所以这个转换执行的是**符合扩展**：它将负的 int 类型的数值提升为一个在数值上相等的 long 类型数值。  

这个加法的右操作数 0xcafebabe 被提升为了 long 类型的数值0xffffffffcafebabeL，这个数值之后被加到了左操作数 0x100000000L 上。当作为 int 类型来被审视时，经过符号扩展之后的右操作数的高 32 位是-1，而左操作数的高 32 位是 1，将这两个数值相加就得到了 0，这也就解释了为什么在程序输出中前导 1 丢失了。  

```
    1111 111
  0xffff ffff cafe babeL
+ 0x0000 0001 0000 0000L
---------------------
  0x0000 0000 cafe babeL  
```

## 解决办法或规则

**修正**：只需用一个 long 十六进制字面常量来表示右操作数即可，这就可以避免了具有破坏力的符号扩展 。

```java
Long.toHexString(0x100000000L + 0xcafebabeL));
```

**教训**：混合类型的计算可能会产生混淆，尤其是十六进制和八进制字面常量无需显式的减号符号就可以表示负的数值。为了避免这种窘境，通常最好是避免混合类型的计算。

对于语言的设计者们来说，应该考虑支持无符号的整数类型，从而根除符号扩展的可能性。 