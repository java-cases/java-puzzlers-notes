# 谜题 9：半斤

## 背景

复合赋值操作符、窄化原始类型转换。

## 代码

给出一个对变量 x 和 i 的声明，使下面代码是一个合法的语句:

```java
x += i;
//但是，它并不是:
x = x + i; 
```

## 陷阱

许多程序员都会认为该迷题中的第一个表达式(x += i)，只是第二个表达式(x = x + i)的简写方式。这两个表达式都被称为赋值表达式。第一条语句使用的是复合赋值操作符，第二条语句使用的是简单赋值操作符(=)。

## 解惑

复合赋值操作符包括 +=、-=、*=、/=、%=、<<=、>>=、>>>=、&=、^= 和|=。

Java 语言规范中，复合赋值 E1 op= E2 等价于简单赋值 E1 = (T) ( (E1) op (E2) )，其中 T 是 E1 的类型，除非 E1 只被计算一次。

换句话说，复合赋值表达式**自动地将它们所执行的计算的结果转型为其左侧变量的类型**。如果结果的类型与该变量的类型相同，那么这个转型不会造成任何影响。然而，**如果结果的类型比该变量的类型要宽，那么复合赋值操作符将悄悄地执行一个窄化原始类型转换**。

复合赋值例子：

```java
short x = 0;
int i = 123456;

//复合赋值编译将不会产生任何错误:
x += i; // 包含了一个隐藏的转型!
```

你可能期望 x 的值在这条语句执行之后是 123456，但是并非如此 l，它的值是-7616。int 类型的数值 123456 对于 short 来说太大了，自动产生的转型悄悄地把 int 数值的高两位给截掉了。

简单赋值例子：
```java
short x = 0;
int i = 123456;

x = x + i; // 不要编译——“可能会丢掉精度”
```
相对应的简单赋值是非法的，因为它试图将 int 数值赋值给 short 变量，它需要一个显式的转型。

## 解决办法或规则

**规则**：

- 请不要将复合赋值操作符作用于 byte、short 或 char 类型的变量上。
- 在将复合赋值操作符作用于 int 类型的变量上时，要确保表达式右侧不是 long、float或 double 类型。
- 在将复合赋值操作符作用于 float 类型的变量上时，要确保表达式右侧不是 double 类型。

这些规则足以防止编译器产生危险的窄化转型。

总之，**复合赋值操作符会悄悄地产生一个转型**。**如果计算结果的类型宽于变量的类型，那么所产生的转型就是一个危险的窄化转型**。这样的转型可能会悄悄地丢弃掉精度或数量值。

对语言设计者来说，也许让复合赋值操作符产生一个不可见的转型本身就是一个错误；对于在复合赋值中的变量类型比计算结果窄的情况，也许应该让其非法才对。

